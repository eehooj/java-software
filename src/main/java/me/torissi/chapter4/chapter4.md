# 문서 관리 시스템

## 요구사항
1. 요구자가 다루는 문서
    * 리포트 : 환자의 수술과 관련된 상담 내용을 기록한 본문
    * 우편물 : 특정 주소로 발송되는 텍스트 문서
    * 이미지 : 치아와 잇몸 엑스레이 사진 (용량이 큼)
2. 기존 환자의 정보 파일을 읽어 색인을 추가하고 검색할 수 있는 형태의 정보로 변환
3. 각각의 문서는 관리 대상 파일의 경로와 어떤 환자의 기록물인지 나타내는 정보도 포함
4. 문서를 쉽게 찾고 다양한 종류의 문서에 특정 정보를 포함하는 문서 검색
5. 차차 다른 종류의 문서도 추가

## 설계 작엄
> 1. TDD 
> 2. void importFile(String path)
>     * 사용자가 문서 관리 시스템으로 임포트하려는 파일의 경로를 받음
>     * 공개 API이므로 Path, File 등의 안전한 형식을 지원하는 클래스 대신 평범한 String 사용
>         * 어떤 파일을 지원해야 하는지 알 수 없기 때문에 String 형식으로 간단하게 처리
> 3. List<Document> contents() 
>     * 문서 관리 시스템에 저장된 모든 문서의 목록을 반환
> 
> 임포터
> * 다양한 종류의 문서를 임포트하는 것이 문서 관리 시스템의 핵심 기능
> * 메인 클래스를 깔끔하고 단순하게 유지하기 위해 다양한 문서를 임포트하는 클래스로 분리
>  * 각각의 임포트 동작을 따로 처리하므로 찾기 쉬움
>  * 이해하기 쉬움
> * 다양한 종류의 문서 임포트를 지원하기 위해 Importer 인터페이스 정의
> ```java
> public interface Importer {
> 
>     Document importFile(File file) throws IOException;
> }
> ```
> 
> Document 클래스 (도메인 클래스 만들기)
> * 검색할 수 있는 다양한 속성 포함
> * 다양한 방법으로 Document를 정의할 수 있지만, 프로그램의 유지보수성과 가독성을 고려해야 함
> * 가장 간단한 방법으로는 Map<String, String>
>     * 응용 프로스램에서 잘 사용하지 않음
>     * 유지보수성과 가독성을 고려해야함
> * 컴포넌트 이름을 구체적으로 지어야함
> * 사용자와 소통할 때 사용하는 언어로 코드를 만들면 유지보수가 쉬워짐 -> Ubiquitous Language(개발자와 사용자 모두 사용하는 언어)
> * 동료나 고객과 대화할 때 소프트웨어의 다양한 기능을 어떤 공통 언어로 약속
> * 이때 사용한 언어를 코드로 매핑하면 코드의 어떤 부분을 바꿔야 하는지 알 수 있음 -> 발견성(discoverability)
> * 강한 형식 사용
>     * 데이터의 사용 방법을 규제할 수 있음
>     * Document는 불변 클래스 -> 클래스를 생성한 다음에는 클래스의 속성을 바꿀 수 없음
>     * Document의 속성에서 오류가 발생하면 해당 Document를 생성한 class에서 확인을 하면 되기 때문에 오류 확인 범위를 줄일 수 있음
> * 도메인 클래스가 아닌 Map<String, String>을 상속하여 만들 경우
>     * 불변성으로 얻을 수 있는 모든 이득이 사라짐
> * => 도메인 클래스를 이용하면 개념에 이름을 붙이고 수행할 수 있는 동작과 값을 제한하므로 발견성을 개성하고 버그 발생 범위를 줄일 수 있음
> ```java
> public class Document {
> 
>     private final Map<String, String> attributes;
> 
>     private Document(Map<String, String> attributes) {
>         this.attributes = attributes;
>     }
>     
>     public String getAttribute(final String attributeName) {
>         return attributes.get(attributeName);
>     }
> }
> /*
> * 생성자를 public으로 만들면 프로젝트 어디서나 그 형식의 객체를 만들 수 있는 문제가 발생
> * 오직 문서 관리 시스템에서만 Document를 만들 수 있어야 하므로 패키지 영역으로 접근을 제한함
> * */
> ```
> 
> Document 속성 및 계층
> * 위 class에서 속성에 String을 사용함 -> 강한 형식 아니지 않나?
> * 속성을 텍스트로 저장하면 텍스트로 속성을 검색할 수 있음
> * 속성을 만드는 Importer의 종류와 관계없이 모든 속성이 아주 일반적인 형식을 갖도로 만들려는 의도도 있음
> * 이를 문자화 형식이라함
> * 프로그램에서 String으로 정보를 전달하는 것은 보통 좋지 않은 방법으로 알려져 있음
> * 속성 값을 다양하게 사용할 때는 그에 맞는 형식으로 파싱하는 것이 좋음
> * 문서의 각 서브 클래스가 전용 필드를 갖지 않도록 모든 알려진 속성을 범용적으로 설계함
> * 클래스 계층으로 인한 이득이 없다면 계층을 추가할 필요가 없음
> 

## 리스코프 치환 원칙(Liskov Substitution Principle)
> * 형식 : 클래스나 인터페이스
> * 하위형식 : 두 형식이 부모와 자식 관계를 이루었음을 의미
> * 클래스 상속이나 인터페이스 구현이 이에 해당
> * 자식 클래스는 부모로부터 물려받은 행동을 유지해야 함
> 
> 하위 형식에서 선행조건을 더할 수 없음
> * 선행 조건은 어떤 코드가 동작하는 조건을 결정함
> * ex) Importer 구현은 임포트하려는 파일이 존재하며, 읽은 수 있을 것이라는 선행조건을 갖음
> ```java
> public class DocumentManagementSystem {
> 
>     private final List<Document> documents = new ArrayList<>();
> 
>  //...
> 
>     public void importFile(final String path) throws IOException {
>         final File file = new File(path);
> 
>         if (!file.exists()) {
>             throw new FileNotFoundException(path);
>         }
> 
>         final int separatorIndex = path.lastIndexOf('.');
> 
>         if (separatorIndex != -1) {
>             if (separatorIndex == path.length()) {
>                 throw new UnknownFileTypeException("파일 경로에서 확장자를 찾을 수 없음: " + path);
>             }
> 
>             final String extension = path.substring(separatorIndex + 1);
>             final Importer importer = extensionToImporter.get(extension);
> 
>             if (importer == null) {
>                 throw new UnknownFileTypeException("파일 확인 필요: " + path);
>             }
> 
>             // 임포트하려는 파일이 존재하며, 읽은 수 있을 것이라는 선행조건 검사 완
>             final Document document = importer.importFile(file); 
>             documents.add(document);
>         } else {
>             throw new UnknownFileTypeException("파일 경로에서 확장자를 찾을 수 없음: " + path);
>         }
>     }
> }
> ```
> * LSP란 부모가 지정한 것보다 더 많은 선행조건을 요구할 수 없음을 의미
> * ex) 부모가 문서의 크기를 제한하지 않았다면 자식은 문서의 크기를 제한할 수 없음
> 
> 하위형식에서 후행조건을 약화시킬 수 없음
> * 후행조건이란 어떤 코드를 실행한 다음에 만족해야 하는 규칙
> * ex) 유효한 파일에 importFile()을 실행했다면 contents()가 반환하는 문서 목록에 그 파일이 반드시 포함되어야 함
> * 부모가 부작용을 포함하거나 어떤 값을 반환한다면 자식도 그래야 함
> 
> 슈퍼형식의 불변자는 하위형식에서 보존됨
> * 상속관계의 부모와 자식 클래스가 있을 때 부모클래스에서 유지되는 모든 불변자는 자식 클래스에서도 유지되어야 함
> 
> 히스토리 규칙
> * 기본적으로 자식 클래스는 부모가 허용하지 않은 상태 변화를 허용하지 않아야 함
> * ex) Document 클래스를 인스턴스화한 다음에는 어떤 속성도 삭제, 추가, 변경할 수 없음
>     * 모든 부모 클래스의 사용자는 Document 클래스의 메소드를 호출했을 때 어떤 일이 일어날 수 있음을 인지할 수 있기 때문

## 대안
> 임포터를 클래스로 만들기
> * 임포터의 클래스 계층을 만들고 인터페이스 대신 가장 상위에 Importer 클래스를 만드는 방법
> * 인터페이스는 여러 개를 한 번에 구현할 수 있지만, 클래스는 일반 인스턴스 필드와 메소드를 갖음
> * but, 쉽게 망가질 수 있는 상속 기반의 클래스를 피해야 하듯이 인터페이스를 이용하는 것이 클래스를 이용하는 것보다는 좋음
> * 문제를 해결해야 하는 도메인에 상태와 많은 동작이 관련되어 있어 강력한 is a 관계를 모델링해야 하는 상황은 클래스 기반의 상속이 적절
> 
> 영역, 캡슐화 선택하기
> * 실제 소프트웨어를 개발할 때 패키지 영역보다 public 영역을 더 많이 사용하긴 함
> * 패키지 영역 접근 제한을 이용해 캡슐화를 구현할 수 있음
>     * 구현 중인 패키지의 세부 정보를 외부로 노출했다면 리팩토링이 어려워짐
>     * 클래스가 외부로 노출되지 않도록 패키지 영역을 사용하면 내부 설계를 쉽게 바꿀 수 있음

## 기존 코드 확장과 재사용
> * 시간이 흐르면서 제품에 기능을 추가하거나, 고객의 요구사항이 바뀌면 프로젝트를 변경해야 함
> * 청구서, 우편물, 리포트가 모두 같은 형식이라면 하나의 코드를 세 개의 임포트에 재사용하면 좋을 듯
> * 유틸리티 클래스, 상속, 도메인클래스 사용 등 세 가지 방법이 있음
> * 유틸리티 클래스 사용
>     * ImportUtil 클래스를 만들어 여러 임포트에서 공유해야 하는 기능을 여기에 구현
>     * 객체지향 프로그래밍의 지향점과는 멀어짐
>        * 객체지향에서는 클래스로 기능을 만듦
>        * 어떤 한 의무 또는 개념 별로 클래스 구현
>     * 유틸리티는 다양한 모음으로 귀결되기 때문에 시간이 지날 수록 갓 클래스의 모양이 될 가능성이 큼
> * 상속사용
>     * 각각의 임포터가 TextImporter 클래스의 상속을 받음
>     * TextImporter는 Importer이고, LSP 규칙을 따름
>     * 실제 관계를 제대로 반영하지 않으면 상속은 쉽게 깨짐
>     * 시간이 흐으고 응용프로그램이 바뀔 때 응용프로그램을 그에 맞게 바꾸는 것보다는 변화를 추상화 하는 것이 좋음
> * 도메인 클래스 사용
>     * 도메인 클래스로 텍스트 파일을 모델링
>     * 도메인 클래스를 이요하면 유연성을 개선할 수 있음
>     * 도메인 클래스를 사용하면 상속같이 쉽게 깨질 수 있는 계층을 만들지 않으면서도 코드를 재사용할 수 있음 
>     * 도메인 클래스 구현
>        * 문서가 항상 text 파일이라는 보장이 없으니 TextFile은 Document의 서브 클래스가 아님
>        * TextFile은 텍스트 파일이라는 기본 개념을 모델링 하는 클래스로 텍스트 파일에서 데이터를 추출하는 메소드를 포함

## 테스트 위생
> * 테스트 대상 코드베이스 뿐만 아니라 테스트 코드도 깔끔하게 유지하며 유지보수하고 개선해야 함을 의미
> * 테스트를 유지보수 하지 않고 방치하면 시간이 지나면서 개발자의 생산성에 부담만 더해짐
> 
> 테스트 이름 짓기
> * 테스트 이름을 지을 때 가독성, 유지보수성, 실행할 수 있는 문서의 역할을 고려
> * 테스트가 실행 중인 리포트를 봤을 때 이름만으로 어떤 기능이 동작하고 않하는지 알 수 있어야 함
> * 동작과 코드가 가급적 일치해야 나중에 다른 개발자가 코드를 쉽게 이해할 수 있음
> * 명사로 이름을 결정하는 것은 안티패턴 -> 테스트 이름은 개념이 아니라 테스트하는 동작을 묘사해야함
> * 테스트 중 실행하는 메소드명을 그대로 사용하는 것도 안티패턴
> * 좋은 이름
>     * 도메인 용어 사용
>        * 문제 도메인을 설명하거나 응용프로그램에서 문제를 지칭할 때 사용하는 용어를 테스트 이름에 사용
>     * 자연어 사용
>        * 모든 테스트 이름은 일반 문장처럼 쉽게 읽을 수 있어야 함
>        * 테스트 이름은 항상 어떤 동작을 쉽게 이해할 수 있도록 묘사
>     * 서술적
>        * 나중에 쉽게 읽을 수 있도록 서술적인 좋은 이름을 붙여야함
> 
> 구현이 아닌 동작
> * 클래스, 컴포넌트, 시스템 테스트를 구현할 때는 대상의 public behavior만 테스트
> * 테스트는 객체 내부 상태나 설계는 고려하지 않고 오직 공개 API 메소드만 이용해 테스트를 수행
> * 테스트를 구현 클래스에 배치하면 테스트를 망가뜨리지 않고 내부를 다른 설계로 리팩토링 할 수 있음
> > 구현에 테스트..? 
> * 게터나 세터 등 비공개 상태를 외부로 노출하면 장기적으로 응용 프로그램을 유지보수하기 어려움
>     * 코드 베이스를 바꾸면 테스트에 영향을 끼침
> 
> 중복배제
> 
> 좋은 진단 (good diagnostics)
> * 실패에 최적화된 테스트를 구현하는 것이 좋음
>     * 테스트가 실패한 이유를 쉽게 이해할 수 있도록 만들어야 함
> * 진단이란 테스트가 실패했을 때 출력하는 메시지와 정보를 의미
> 
> 오류 상황 테스트
> 
> 상수
> 