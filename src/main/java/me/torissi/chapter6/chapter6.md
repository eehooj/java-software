# 트우터

## 목표
1. 큰 그림을 서로 다른 작은 아키텍처 문제로 쪼개는 방법
2. 테스트 더블(모킹)로 코드베이스의 다른 컴포넌트와의 상호작용을 고립하고 테스트 하는 방법
3. 요구 사항이 응용 프로그램 도메인 코어로 이어지도록 뒤집어 생각하는 방법

## 요구사항
- 트웃 : 사용자가 게시하는 각각의 마이크로블로그
- 스트림 : 사용자는 연속적인 트웃 스트림을 갖음
- 팔로우 : 다른 사용자를 팔로우해야 그 사용자가 무엇을 트우팅했는지 알 수 있음
1. 고유의 사용자 ID롸 비밀번호로 트우터에 로그인
2. 각 사용자는 자신이 팔로우하는 사용자 집합을 갖음
3. 사용자는 트웃을 전송할 수 있으며 로그인한 모든 팔로워는 이 트웃을 바로 볼 수 있음
4. 사용자가 로그인하면 최종 로그인한 이후로 게시된 팔로워의 모든 트웃을 볼 수 있음
5. 자신의 트웃을 삭제할 수 있으며, 팔로워는 삭제된 트웃을 볼 수 없음
6. 사용자는 모바일이나 웹사이트로 로그인할 수 있음

=> 핵심은 팔로워의 트웃을 바로 볼 수 있는 기능

## 설계 개요
> * 다양한 환경의 사용자가 어떻게 서로 통신할 수 있을까?
>   * 보통은 클라이언트 서버 모델로 해결
>       * 컴퓨터를 클라이언트와 서버 두 그룹으로 분리함
>       * 클라이언트 그룹 : 서비스를 사용하는 그룹
>       * 서버 그룹 : 관련 서비스를 제공하는 그룹
>       * 예제에서는 웹사이트나 스마트폰 응용프로그램이 클라이언트 그룹이고, 트우터 서버와 통신하는 UI를 제공
>       * 서버는 대부분의 비즈니스 로직을 처리하고, 다양한 클라이언트로부터 트웃을 받거나 전송
> 
> 1. 풀기반 (pull-based)
>   * 풀기반 통신은 점대점(point-to-point) 또는 요청 응답(request-response) 통신 형식으로 불림
>   * 클라이언트가 서버로 정보를 요청
>   * 대부분의 웹에서 이 형식을 사용
>   * 웹 사이트로 접속할 때 클라이언트는 서버로 HTTP 요청을 보내 페이지의 데이터를 가져옴
>   * 클라이언트가 어떤 정보를 가져올 지 결정하는 상항에서 유용
> 
> 2. 푸시기반 (push-based)
>   * 리액티브(reactive) 또는 이벤트 주도(event-driven) 통신이라 불림
>   * 작성자가 방출한 이벤트 스트림을 여러 구독자가 수신
>   * 일대일 통신 뿐만 아니라 일대다 통신도 지원
>   * 여러 컴포넌트 간에 다양한 이벤트의 의사소통이 발생하는 상황에서 유용
> 
> => 예시에서는 트웃의 스트림이 주를 이루기 때문에 푸시형식의 통신 방식이 적합
> => 풀기반은 사용자가 정기적으로 데이터를 요청해야함

## 이벤트에서 설계까지
> 1. 통신 (이벤트를 전송하고 수신하는 기능을 어떤 기술로 구현할거?)
>   * 웹소켓(WebSocket)
>       * TCP 스트림으로 양방향 이벤트 통신을 지원하는 가벼운 통신 프로토콜
>       * 웹 브라우저에서 지원하는 웹 서버와 웹 브라우저 사이의 이벤트 주도 통신에 주로 사용
>   * SQS(Simple Queue Service) - Message Queue
>       * 아마존 서비스
>       * 호스트된 클라우드 기반 메시지 큐를 메시지 송출이나 수신에 점점 많이 사용
>       * 메시지 큐는 그룹 내의 프로세스 중 한 프로세스가 전송된 메시지를 받아 처리하는 상호 프로세스 통신 방식
>       * 호스트된 서비스를 이용하면 안정적인 호스팅을 제공하기 위해 직접 관리하지 않아도 되어 편리
>   * 다양한 통신 방식을 혼합해서 사용할 수 있음
> 
> 2. GUI
>   * UI 통신 기술이나 UI를 서버의 비즈니스 로직과 결합하면 몇 가지 단점이 있음
>       * 테스트하기 어렵고 테스트 실행도 느려짐 
>           * 모든 테스트가 실행 중인 메인 서버로 이벤트를 발행하거나 수신해야 하기 때문
>       * 단일 책임 원칙을 위반
>   * 메시징을 코어 비즈니스 로직과 분리할 수 있도록 추상화 필요
>   * 클라이언트에세 메시지를 전송하고 클라이언트의 메시지를 수신하는 인터페이스가 필요
> 
> 3. 영구 저장
>   * 수신한 데이터를 어떻게 저장할까?
>       * 직접 인덱스하고 검색할 수 있는 텍스트 파일
>           * 기록된 데이터를 쉽게 볼 수 있으며 다른 응용프로그램과의 디펜던시를 줄일 수 있음
>       * 전통적 SQL 데이터베이스 
>           * 모두가 알고 있으며 잘 검증된 시스템으로 강력한 질의를 지원
>       * NoSQL 데이터베이스
>           * 다양한 유스케이스, 질의 언어, 데이터 저장 모델을 지원
>   * 개발을 진행하다 보면 어떤 기술이 적합한지, 요구사항 등이 계속 바뀌기 때문에 고민 많이 함
> 
> 4. 육각형 아키텍처
>   * 앨리스터 콕번이 정립한 포트와 어댑터(ports and adapters) 또는 육각형 아키텍처(hexagonal architecture)
>   * 이 아키텍처에서 응용프로그램의 코어는 우리가 구현하는 비즈니스 로직
>   * 다양한 구현은 코어와 분리되어 있음
>   * 코어 비즈니스 로직과 분리하고 싶은 기술이 있다면 포트를 이용해 코어 비즈니스 로직과 연결하여 전달
>   * 어댑터는 분리된 특정 기술을 구현한 코드
>   * 포트와 어댑터를 추상화해야함
>   * 어떤 기능을 포트로 하고, 어떤 기능을 코어 도메인으로 분리해야 하는 지에 대해서는 규칙이 따로 없음
>       * 개인적인 판단과 환경에 따라 응용프로그램에 맞는 결정을 하면 됨
>       * 보통 비즈니스 문제를 해결하는 데 꼭 필요한 기능을 응용프로그램의 코어로 분류
>       * 그 외 나머지 특정 기술에 종속된 기능이나 통신 관련 기능은 코어 의 외부 세계로 분류하는 것이 일반적
>   * 포트와 어댑터의 목표는 응용프로그램의 코어와 특정 어댑터 구현의 결합을 제거하는 것
>       * 즉, 인터페이스로 다양한 어댑터를 추상화해야 함

## 작업 순서
> - 설계를 더 구체화하고, 다이어그램을 세부적으로 완성하면서 어떤 클래스로 무슨 기능을 구현할지 결정할 차례
> - 설계를 충분히 고민하지 않고 바로 코딩을 시작하면 혼돈을 초래
> - 그러나 코딩 없는 아키텍처는 무너지기 쉽상이며 현실과 동떨어진 결과가 되기 쉬움
> 
